<!DOCTYPE html>
<html>
<head>
    <title>WebGL Landscape</title>
</head>
<body style="margin:0">
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.querySelector("#glCanvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGL not available");
        }

        // Vertex shader
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
            attribute vec4 position;
            void main() {
                gl_Position = position;
            }
        `);
        gl.compileShader(vertexShader);

        // Fragment shader with time uniform for day/night cycle
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
            precision mediump float;
            uniform float time;
            
            vec3 getSkyColor(float t) {
                vec3 dayColor = vec3(0.53, 0.81, 0.92);
                vec3 nightColor = vec3(0.1, 0.1, 0.3);
                return mix(dayColor, nightColor, sin(t) * 0.5 + 0.5);
            }

            vec3 getGroundColor() {
                return vec3(0.2, 0.5, 0.2);
            }

            vec3 getHouseColor(vec2 pos) {
                if (pos.x > 0.1 && pos.x < 0.3 && pos.y > -0.2 && pos.y < 0.1) {
                    return vec3(0.6, 0.3, 0.1); // House body
                }
                if (pos.x > 0.1 && pos.x < 0.3 && pos.y > 0.1 && pos.y < 0.2) {
                    return vec3(0.7, 0.2, 0.1); // Roof
                }
                return vec3(0.0);
            }

            vec3 getTreeColor(vec2 pos) {
                if (pos.x > -0.2 && pos.x < -0.15 && pos.y > -0.2 && pos.y < 0.0) {
                    return vec3(0.4, 0.2, 0.0); // Trunk
                }
                if (pos.x > -0.25 && pos.x < -0.1 && pos.y > 0.0 && pos.y < 0.3) {
                    return vec3(0.1, 0.4, 0.1); // Leaves
                }
                return vec3(0.0);
            }

            vec3 getSunMoonColor(vec2 pos, float t) {
                vec2 center = vec2(sin(t) * 0.7, cos(t) * 0.7);
                float dist = distance(pos, center);
                if (dist < 0.1) {
                    return mix(vec3(1.0, 0.8, 0.0), vec3(0.9), sin(t) * 0.5 + 0.5);
                }
                return vec3(0.0);
            }

            void main() {
                vec2 pos = gl_FragCoord.xy / vec2(${canvas.width}.0, ${canvas.height}.0) * 2.0 - 1.0;
                pos.x *= ${canvas.width}.0/${canvas.height}.0;
                
                vec3 color = getSkyColor(time);
                
                // Ground
                if (pos.y < -0.2) {
                    color = getGroundColor();
                }
                
                // House
                vec3 house = getHouseColor(pos);
                if (house != vec3(0.0)) {
                    color = house;
                }
                
                // Tree
                vec3 tree = getTreeColor(pos);
                if (tree != vec3(0.0)) {
                    color = tree;
                }
                
                // Sun/Moon
                vec3 sunMoon = getSunMoonColor(pos, time);
                if (sunMoon != vec3(0.0)) {
                    color = sunMoon;
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `);
        gl.compileShader(fragmentShader);

        // Check for shader compilation errors
        function checkShaderCompileStatus(shader) {
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed with: ' + gl.getShaderInfoLog(shader));
            }
        }

        // Check for program linking errors
        function checkProgramLinkStatus(program) {
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link failed with: ' + gl.getProgramInfoLog(program));
            }
        }

        // After compiling shaders
        checkShaderCompileStatus(vertexShader);
        checkShaderCompileStatus(fragmentShader);

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // After linking program
        checkProgramLinkStatus(program);

        // Create rectangle covering entire canvas
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const timeLocation = gl.getUniformLocation(program, "time");
        let startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            gl.uniform1f(timeLocation, currentTime);
            
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        render();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });
    </script>
</body>
</html>